{"version":3,"file":"index.js.map","sources":["index.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nvar _a;\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { Sender } from \"@microsoft/applicationinsights-channel-js\";\r\nimport { DEFAULT_BREEZE_PATH, parseConnectionString } from \"@microsoft/applicationinsights-common\";\r\nimport { AppInsightsCore, cfgDfValidate, createDynamicConfig, onConfigChange, proxyFunctions } from \"@microsoft/applicationinsights-core-js\";\r\nimport { createSyncPromise, doAwaitResponse } from \"@nevware21/ts-async\";\r\nimport { isNullOrUndefined, isPromiseLike, isString, objDefine, throwError } from \"@nevware21/ts-utils\";\r\nimport { _DYN_CONNECTION_STRING, _DYN_ENDPOINT_URL, _DYN_INSTRUMENTATION_KEY, _DYN_USER_OVERRIDE_ENDPOI0 } from \"./__DynamicConstants\";\r\nvar UNDEFINED_VALUE = undefined;\r\nvar defaultConfigValues = (_a = {\r\n        diagnosticLogInterval: cfgDfValidate(_chkDiagLevel, 10000)\r\n    },\r\n    _a[_DYN_CONNECTION_STRING /* @min:connectionString */] = UNDEFINED_VALUE,\r\n    _a.endpointUrl = UNDEFINED_VALUE,\r\n    _a[_DYN_INSTRUMENTATION_KEY /* @min:instrumentationKey */] = UNDEFINED_VALUE,\r\n    _a.extensionConfig = {},\r\n    _a);\r\nfunction _chkDiagLevel(value) {\r\n    // Make sure we have a value > 0\r\n    return value && value > 0;\r\n}\r\n/**\r\n * @export\r\n */\r\nvar ApplicationInsights = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ApplicationInsights.\r\n     * @param config - The configuration to use for this ApplicationInsights instance\r\n     */\r\n    function ApplicationInsights(config) {\r\n        var core = new AppInsightsCore();\r\n        var _config;\r\n        // initialize the queue and config in case they are undefined\r\n        if (isNullOrUndefined(config) ||\r\n            (isNullOrUndefined(config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */]) && isNullOrUndefined(config[_DYN_CONNECTION_STRING /* @min:%2econnectionString */]))) {\r\n            throwError(\"Invalid input configuration\");\r\n        }\r\n        dynamicProto(ApplicationInsights, this, function (_self) {\r\n            // Define _self.config\r\n            objDefine(_self, \"config\", {\r\n                g: function () { return _config; }\r\n            });\r\n            _initialize();\r\n            _self.initialize = _initialize;\r\n            _self.track = _track;\r\n            proxyFunctions(_self, core, [\r\n                \"flush\",\r\n                \"pollInternalLogs\",\r\n                \"stopPollingInternalLogs\",\r\n                \"unload\",\r\n                \"getPlugin\",\r\n                \"addPlugin\",\r\n                \"evtNamespace\",\r\n                \"addUnloadCb\",\r\n                \"onCfgChange\",\r\n                \"getTraceCtx\",\r\n                \"updateCfg\",\r\n                \"addTelemetryInitializer\"\r\n            ]);\r\n            function _initialize() {\r\n                var cfgHandler = createDynamicConfig(config || {}, defaultConfigValues);\r\n                _config = cfgHandler.cfg;\r\n                core.addUnloadHook(onConfigChange(cfgHandler, function () {\r\n                    var configCs = _config[_DYN_CONNECTION_STRING /* @min:%2econnectionString */];\r\n                    if (isPromiseLike(configCs)) {\r\n                        var ikeyPromise = createSyncPromise(function (resolve, reject) {\r\n                            doAwaitResponse(configCs, function (res) {\r\n                                var curCs = res.value;\r\n                                var ikey = _config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];\r\n                                if (!res.rejected && curCs) {\r\n                                    // replace cs with resolved values in case of circular promises\r\n                                    _config[_DYN_CONNECTION_STRING /* @min:%2econnectionString */] = curCs;\r\n                                    var resolvedCs = parseConnectionString(curCs);\r\n                                    ikey = resolvedCs.instrumentationkey || ikey;\r\n                                }\r\n                                resolve(ikey);\r\n                            });\r\n                        });\r\n                        var urlPromise = createSyncPromise(function (resolve, reject) {\r\n                            doAwaitResponse(configCs, function (res) {\r\n                                var curCs = res.value;\r\n                                var url = _config[_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */];\r\n                                if (!res.rejected && curCs) {\r\n                                    var resolvedCs = parseConnectionString(curCs);\r\n                                    var ingest = resolvedCs.ingestionendpoint;\r\n                                    url = ingest ? ingest + DEFAULT_BREEZE_PATH : url;\r\n                                }\r\n                                resolve(url);\r\n                            });\r\n                        });\r\n                        _config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */] = ikeyPromise;\r\n                        _config[_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */] = _config[_DYN_USER_OVERRIDE_ENDPOI0 /* @min:%2euserOverrideEndpointUrl */] || urlPromise;\r\n                    }\r\n                    if (isString(configCs)) {\r\n                        var cs = parseConnectionString(configCs);\r\n                        var ingest = cs.ingestionendpoint;\r\n                        _config[_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */] = _config[_DYN_USER_OVERRIDE_ENDPOI0 /* @min:%2euserOverrideEndpointUrl */] ? _config[_DYN_USER_OVERRIDE_ENDPOI0 /* @min:%2euserOverrideEndpointUrl */] : (ingest + DEFAULT_BREEZE_PATH); // only add /v2/track when from connectionstring\r\n                        _config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */] = cs.instrumentationkey || _config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];\r\n                    }\r\n                    // userOverrideEndpointUrl have the highest priority\r\n                    _config[_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */] = _config[_DYN_USER_OVERRIDE_ENDPOI0 /* @min:%2euserOverrideEndpointUrl */] ? _config[_DYN_USER_OVERRIDE_ENDPOI0 /* @min:%2euserOverrideEndpointUrl */] : _config[_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */];\r\n                }));\r\n                // initialize core\r\n                core.initialize(_config, [new Sender()]);\r\n            }\r\n        });\r\n        function _track(item) {\r\n            if (item) {\r\n                // to pass sender.processTelemetry()\r\n                item.baseData = item.baseData || {};\r\n                item.baseType = item.baseType || \"EventData\";\r\n            }\r\n            core.track(item);\r\n        }\r\n    }\r\n    /**\r\n     * Initialize this instance of ApplicationInsights\r\n     *\r\n     */\r\n    ApplicationInsights.prototype.initialize = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Send a manually constructed custom event\r\n     * @param item - The custom event to send\r\n     */\r\n    ApplicationInsights.prototype.track = function (item) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Immediately send all batched telemetry\r\n     * @param async - Should the flush be performed asynchronously\r\n     */\r\n    ApplicationInsights.prototype.flush = function (async) {\r\n        if (async === void 0) { async = true; }\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    ApplicationInsights.prototype.pollInternalLogs = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    ApplicationInsights.prototype.stopPollingInternalLogs = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Unload and Tear down the SDK and any initialized plugins, after calling this the SDK will be considered\r\n     * to be un-initialized and non-operational, re-initializing the SDK should only be attempted if the previous\r\n     * unload call return `true` stating that all plugins reported that they also unloaded, the recommended\r\n     * approach is to create a new instance and initialize that instance.\r\n     * This is due to possible unexpected side effects caused by plugins not supporting unload / teardown, unable\r\n     * to successfully remove any global references or they may just be completing the unload process asynchronously.\r\n     * @param isAsync - Can the unload be performed asynchronously (default)\r\n     * @param unloadComplete - An optional callback that will be called once the unload has completed\r\n     * @param cbTimeout - An optional timeout to wait for any flush operations to complete before proceeding with the\r\n     * unload. Defaults to 5 seconds.\r\n     * @returns Nothing or if occurring asynchronously a [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * which will be resolved once the unload is complete, the [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * will only be returned when no callback is provided and isAsync is true\r\n     */\r\n    ApplicationInsights.prototype.unload = function (isAsync, unloadComplete, cbTimeout) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Find and return the (first) plugin with the specified identifier if present\r\n     * @param pluginIdentifier - The identifier of the plugin to search for\r\n     */\r\n    ApplicationInsights.prototype.getPlugin = function (pluginIdentifier) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Add a new plugin to the installation\r\n     * @param plugin - The new plugin to add\r\n     * @param replaceExisting - should any existing plugin be replaced\r\n     * @param doAsync - Should the add be performed asynchronously\r\n     */\r\n    ApplicationInsights.prototype.addPlugin = function (plugin, replaceExisting, doAsync, addCb) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Returns the unique event namespace that should be used\r\n     */\r\n    ApplicationInsights.prototype.evtNamespace = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Add an unload handler that will be called when the SDK is being unloaded\r\n     * @param handler - the handler\r\n     */\r\n    ApplicationInsights.prototype.addUnloadCb = function (handler) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Gets the current distributed trace context for this instance if available\r\n     */\r\n    ApplicationInsights.prototype.getTraceCtx = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    ApplicationInsights.prototype.addTelemetryInitializer = function (telemetryInitializer) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Update the configuration used and broadcast the changes to all loaded plugins\r\n     * @param newConfig - The new configuration is apply\r\n     * @param mergeExisting - Should the new configuration merge with the existing or just replace it. Default is to merge.\r\n     */\r\n    ApplicationInsights.prototype.updateCfg = function (newConfig, mergeExisting) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Watches and tracks changes for accesses to the current config, and if the accessed config changes the\r\n     * handler will be recalled.\r\n     * @param handler - The handler to call when the configuration changes\r\n     * @returns A watcher handler instance that can be used to remove itself when being unloaded\r\n     */\r\n    ApplicationInsights.prototype.onCfgChange = function (handler) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    return ApplicationInsights;\r\n}());\r\nexport { ApplicationInsights };\r\nexport { AppInsightsCore, arrForEach, isNullOrUndefined, throwError, proxyFunctions } from \"@microsoft/applicationinsights-core-js\";\r\nexport { SeverityLevel } from \"@microsoft/applicationinsights-common\";\r\nexport { Sender } from \"@microsoft/applicationinsights-channel-js\";\r\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":";;;;AAA4D;AAC1B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;8DA0GM,CAAC;;;;;+BACwB;AAC/B;AACA;AACA;AACA;AACA;AACA"}